{"type":"deployment","id":"11155111_290_MerkleERC721TokenLinearERC20TransferVesting","batch":"test1","batchIndex":0,"deploymentAddress":"0x4019ce0Ec071C66E8De709C5CbE9c6925B75085a","constructorArgs":["0x2902b792Af43Ea1481569bc35b62a31BB2C20E95","10000000000000000000000",1717632000,604800,"0x302f24131c5d4f4bbfc308760fd33784076b2c14cbf5043fa944d0d6c168e714","0xa84a1cc30864514afEB1E4f9cf8440467308b892"],"to":"0x4e59b44847b379578588920ca78fbf26c0b4956c","value":"0","data":"0x000000000000000000000000000000000000000000000000706c6f706d656e7a6101403461011857601f610a2838819003918201601f19168301916001600160401b0383118484101761011c5780849260c0946040528339810103126101185780516001600160a01b039081811681036101185760208301516001600160601b03811681036101185761007460408501610130565b9061008160608601610130565b9260a0608087015196015194851685036101185760805260a05260c05260e052610100918252610120908152604051906108e39283610145843960805183818160ac0152610376015260a0518381816101ce0152610727015260c05183818161018b0152610769015260e0518381816104d8015261074801525182818161014801526106f001525181818161023501526105fb0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b51906001600160401b03821682036101185756fe6080604090808252600480361015610015575f80fd5b5f3560e01c9182630fb5a6b4146104ba575081632d087243146102935781635daa3160146102645781636537188314610221578163a94d373b146101f2578163aa8c217c146101af578163be9a65551461016b578163d8176aba14610131578163e115a2271461010d578163e4bf01a8146100df575063fc0c546a14610099575f80fd5b346100db575f3660031901126100db57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5f80fd5b82346100db5760203660031901126100db576001600160601b0361010560209335610717565b915191168152f35b82346100db576020906101286101223661054e565b90610674565b90519015158152f35b82346100db575f3660031901126100db57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b82346100db575f3660031901126100db576020905167ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b82346100db575f3660031901126100db57602090516001600160601b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b82346100db5760203660031901126100db57602091355f525f82526001600160601b03815f2054169051908152f35b82346100db575f3660031901126100db57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b82346100db5760203660031901126100db57610282602092356105d6565b90516001600160a01b039091168152f35b9050346100db576102a33661054e565b906102ae8282610674565b1561046757506102bd816105d6565b6102c682610717565b915f526020905f8252845f2080546001600160601b038095169485818316018181116104545716906001600160601b03191617905584517fc0e523490dd523c33b1878c9eb14ff46991e3f5b2cd33710918618f2a39cba1b8660018060a01b03809416928381528686820152a18551938385019163a9059cbb60e01b83526024860152604485015260448452608084019167ffffffffffffffff928581108482111761044157915f9291839289527f00000000000000000000000000000000000000000000000000000000000000001695519082875af13d15610434573d91821161042157906103d5918651916103c685601f19601f840116018461052c565b82523d5f8584013e5b8461084a565b8051918215159182610400575b505090506103ec57005b6024925191635274afe760e01b8352820152fd5b8092508193810103126100db5701518015908115036100db57805f806103e2565b604185634e487b7160e01b5f525260245ffd5b6103d591506060906103cf565b604187634e487b7160e01b5f525260245ffd5b601188634e487b7160e01b5f525260245ffd5b8351637ae3b63360e11b815292830193909352825160448301819052909260648301916020918201915f5b8281106104a6578580868960248301520390fd5b835185529381019392810192600101610492565b346100db575f3660031901126100db5760209067ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6040810190811067ffffffffffffffff82111761051857604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761051857604052565b60406003198201126100db5760043567ffffffffffffffff918282116100db57806023830112156100db578160040135928311610518578260051b6020926040519461059d602084018761052c565b8552602460208601928201019283116100db57602401905b8282106105c757505050509060243590565b813581529083019083016105b5565b6040516331a9108f60e11b815260048101919091526001600160a01b036020826024817f000000000000000000000000000000000000000000000000000000000000000085165afa918215610669575f9261063057505090565b9091506020813d602011610661575b8161064c6020938361052c565b810103126100db575190811681036100db5790565b3d915061063f565b6040513d5f823e3d90fd5b919060409060405190602091828101918252828152610692816104fc565b5190206040518281019182528281526106aa816104fc565b519020905f915b85518310156106ee57818360051b87010151908181105f146106df575f5281526001835f205b9201916106b1565b905f5281526001835f206106d7565b7f0000000000000000000000000000000000000000000000000000000000000000149450505050565b61078d67ffffffffffffffff42167f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006107c6565b905f525f6020526001600160601b0390818060405f2054169116039081116107b25790565b634e487b7160e01b5f52601160045260245ffd5b90919267ffffffffffffffff808093169116928184105f146107eb5750505050505f90565b8216928382018381116107b25783168110610807575050505090565b93919293038281116107b2576001600160601b03928391169116029081169081036107b2578115610836570490565b634e487b7160e01b5f52601260045260245ffd5b90610871575080511561085f57805190602001fd5b604051630a12f52160e11b8152600490fd5b815115806108a4575b610882575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561087a56fea2646970667358221220017868609fe98fa95cbee57382af47ec0e851e8c7645be9bc7308a80ba641f1564736f6c634300081700330000000000000000000000002902b792af43ea1481569bc35b62a31bb2c20e9500000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000000000000000000000000000000000006660fc000000000000000000000000000000000000000000000000000000000000093a80302f24131c5d4f4bbfc308760fd33784076b2c14cbf5043fa944d0d6c168e714000000000000000000000000a84a1cc30864514afeb1e4f9cf8440467308b892","gas":"556346","from":"0xaF7E68bCb2Fc7295492A00177f14F59B92814e70","transactionSettings":{"chainId":11155111,"nonce":"290","baseFee":"24934228333","priorityFee":"1000000000"},"salt":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000plopmenz","artifact":{"abi":[{"type":"constructor","inputs":[{"name":"_token","type":"address","internalType":"contract IERC20"},{"name":"_amount","type":"uint96","internalType":"uint96"},{"name":"_start","type":"uint64","internalType":"uint64"},{"name":"_duration","type":"uint64","internalType":"uint64"},{"name":"_merkletreeRoot","type":"bytes32","internalType":"bytes32"},{"name":"_ownerToken","type":"address","internalType":"contract IERC721"}],"stateMutability":"nonpayable"},{"type":"function","name":"amount","inputs":[],"outputs":[{"name":"","type":"uint96","internalType":"uint96"}],"stateMutability":"view"},{"type":"function","name":"beneficiary","inputs":[{"name":"_tokenId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"duration","inputs":[],"outputs":[{"name":"","type":"uint64","internalType":"uint64"}],"stateMutability":"view"},{"type":"function","name":"merkletreeRoot","inputs":[],"outputs":[{"name":"","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"ownerToken","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IERC721"}],"stateMutability":"view"},{"type":"function","name":"releasable","inputs":[{"name":"_tokenId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint96","internalType":"uint96"}],"stateMutability":"view"},{"type":"function","name":"release","inputs":[{"name":"_proof","type":"bytes32[]","internalType":"bytes32[]"},{"name":"_tokenId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"released","inputs":[{"name":"tokenId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint96","internalType":"uint96"}],"stateMutability":"view"},{"type":"function","name":"start","inputs":[],"outputs":[{"name":"","type":"uint64","internalType":"uint64"}],"stateMutability":"view"},{"type":"function","name":"token","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IERC20"}],"stateMutability":"view"},{"type":"function","name":"verifyTokenid","inputs":[{"name":"_proof","type":"bytes32[]","internalType":"bytes32[]"},{"name":"_tokenId","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"valid","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"event","name":"ERC20Released","inputs":[{"name":"beneficiary","type":"address","indexed":false,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"AddressInsufficientBalance","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"FailedInnerCall","inputs":[]},{"type":"error","name":"InvalidProof","inputs":[{"name":"proof","type":"bytes32[]","internalType":"bytes32[]"},{"name":"tokenId","type":"uint256","internalType":"uint256"}]},{"type":"error","name":"SafeERC20FailedOperation","inputs":[{"name":"token","type":"address","internalType":"address"}]}],"bytecode":"0x6101403461011857601f610a2838819003918201601f19168301916001600160401b0383118484101761011c5780849260c0946040528339810103126101185780516001600160a01b039081811681036101185760208301516001600160601b03811681036101185761007460408501610130565b9061008160608601610130565b9260a0608087015196015194851685036101185760805260a05260c05260e052610100918252610120908152604051906108e39283610145843960805183818160ac0152610376015260a0518381816101ce0152610727015260c05183818161018b0152610769015260e0518381816104d8015261074801525182818161014801526106f001525181818161023501526105fb0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b51906001600160401b03821682036101185756fe6080604090808252600480361015610015575f80fd5b5f3560e01c9182630fb5a6b4146104ba575081632d087243146102935781635daa3160146102645781636537188314610221578163a94d373b146101f2578163aa8c217c146101af578163be9a65551461016b578163d8176aba14610131578163e115a2271461010d578163e4bf01a8146100df575063fc0c546a14610099575f80fd5b346100db575f3660031901126100db57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5f80fd5b82346100db5760203660031901126100db576001600160601b0361010560209335610717565b915191168152f35b82346100db576020906101286101223661054e565b90610674565b90519015158152f35b82346100db575f3660031901126100db57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b82346100db575f3660031901126100db576020905167ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b82346100db575f3660031901126100db57602090516001600160601b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b82346100db5760203660031901126100db57602091355f525f82526001600160601b03815f2054169051908152f35b82346100db575f3660031901126100db57517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b82346100db5760203660031901126100db57610282602092356105d6565b90516001600160a01b039091168152f35b9050346100db576102a33661054e565b906102ae8282610674565b1561046757506102bd816105d6565b6102c682610717565b915f526020905f8252845f2080546001600160601b038095169485818316018181116104545716906001600160601b03191617905584517fc0e523490dd523c33b1878c9eb14ff46991e3f5b2cd33710918618f2a39cba1b8660018060a01b03809416928381528686820152a18551938385019163a9059cbb60e01b83526024860152604485015260448452608084019167ffffffffffffffff928581108482111761044157915f9291839289527f00000000000000000000000000000000000000000000000000000000000000001695519082875af13d15610434573d91821161042157906103d5918651916103c685601f19601f840116018461052c565b82523d5f8584013e5b8461084a565b8051918215159182610400575b505090506103ec57005b6024925191635274afe760e01b8352820152fd5b8092508193810103126100db5701518015908115036100db57805f806103e2565b604185634e487b7160e01b5f525260245ffd5b6103d591506060906103cf565b604187634e487b7160e01b5f525260245ffd5b601188634e487b7160e01b5f525260245ffd5b8351637ae3b63360e11b815292830193909352825160448301819052909260648301916020918201915f5b8281106104a6578580868960248301520390fd5b835185529381019392810192600101610492565b346100db575f3660031901126100db5760209067ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b6040810190811067ffffffffffffffff82111761051857604052565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff82111761051857604052565b60406003198201126100db5760043567ffffffffffffffff918282116100db57806023830112156100db578160040135928311610518578260051b6020926040519461059d602084018761052c565b8552602460208601928201019283116100db57602401905b8282106105c757505050509060243590565b813581529083019083016105b5565b6040516331a9108f60e11b815260048101919091526001600160a01b036020826024817f000000000000000000000000000000000000000000000000000000000000000085165afa918215610669575f9261063057505090565b9091506020813d602011610661575b8161064c6020938361052c565b810103126100db575190811681036100db5790565b3d915061063f565b6040513d5f823e3d90fd5b919060409060405190602091828101918252828152610692816104fc565b5190206040518281019182528281526106aa816104fc565b519020905f915b85518310156106ee57818360051b87010151908181105f146106df575f5281526001835f205b9201916106b1565b905f5281526001835f206106d7565b7f0000000000000000000000000000000000000000000000000000000000000000149450505050565b61078d67ffffffffffffffff42167f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000006107c6565b905f525f6020526001600160601b0390818060405f2054169116039081116107b25790565b634e487b7160e01b5f52601160045260245ffd5b90919267ffffffffffffffff808093169116928184105f146107eb5750505050505f90565b8216928382018381116107b25783168110610807575050505090565b93919293038281116107b2576001600160601b03928391169116029081169081036107b2578115610836570490565b634e487b7160e01b5f52601260045260245ffd5b90610871575080511561085f57805190602001fd5b604051630a12f52160e11b8152600490fd5b815115806108a4575b610882575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561087a56fea2646970667358221220017868609fe98fa95cbee57382af47ec0e851e8c7645be9bc7308a80ba641f1564736f6c63430008170033","compiler":{"version":"v0.8.23+commit.f704f362"},"contractName":"src/MerkleERC721TokenLinearERC20TransferVesting.sol:MerkleERC721TokenLinearERC20TransferVesting","jsonDescription":{"language":"Solidity","sources":{"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/MerkleERC721TokenLinearERC20TransferVesting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20TransferReward, IERC20} from \"./rewards/ERC20TransferReward.sol\";\nimport {MerkleTokenLinearVesting} from \"./vesting/MerkleTokenLinearVesting.sol\";\n\nimport {IERC721} from \"../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\";\n\ncontract MerkleERC721TokenLinearERC20TransferVesting is ERC20TransferReward, MerkleTokenLinearVesting {\n    IERC721 public immutable ownerToken;\n\n    constructor(\n        IERC20 _token,\n        uint96 _amount,\n        uint64 _start,\n        uint64 _duration,\n        bytes32 _merkletreeRoot,\n        IERC721 _ownerToken\n    ) ERC20TransferReward(_token) MerkleTokenLinearVesting(_amount, _start, _duration, _merkletreeRoot) {\n        ownerToken = _ownerToken;\n    }\n\n    /// @notice Getter for the address that will receive the tokens.\n    function beneficiary(uint256 _tokenId) public view virtual override returns (address) {\n        return ownerToken.ownerOf(_tokenId);\n    }\n\n    function reward(address _beneficiary, uint96 _amount)\n        internal\n        virtual\n        override(ERC20TransferReward, MerkleTokenLinearVesting)\n    {\n        super.reward(_beneficiary, _amount);\n    }\n}\n"},"src/rewards/ERC20TransferReward.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeERC20, IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract ERC20TransferReward {\n    event ERC20Released(address beneficiary, uint256 amount);\n\n    IERC20 public immutable token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    /// @notice Release the tokens that have already vested.\n    function reward(address _beneficiary, uint96 _amount) internal virtual {\n        emit ERC20Released(_beneficiary, _amount);\n        SafeERC20.safeTransfer(token, _beneficiary, _amount);\n    }\n}\n"},"src/vesting/MerkleTokenLinearVesting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {VestingUtils} from \"./VestingUtils.sol\";\nimport {MerkleProof} from \"../../lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\n\nabstract contract MerkleTokenLinearVesting {\n    error InvalidProof(bytes32[] proof, uint256 tokenId);\n\n    uint96 public immutable amount;\n    uint64 public immutable start;\n    uint64 public immutable duration;\n    bytes32 public immutable merkletreeRoot;\n\n    mapping(uint256 tokenId => uint96) public released;\n\n    constructor(uint96 _amount, uint64 _start, uint64 _duration, bytes32 _merkletreeRoot) {\n        amount = _amount;\n        start = _start;\n        duration = _duration;\n        merkletreeRoot = _merkletreeRoot;\n    }\n\n    function reward(address _beneficiary, uint96 _amount) internal virtual;\n\n    /// @notice Getter for the address that will receive the tokens.\n    function beneficiary(uint256 _tokenId) public view virtual returns (address);\n\n    /// @notice Getter for the amount of releasable tokens.\n    function releasable(uint256 _tokenId) public view virtual returns (uint96) {\n        return VestingUtils.linearVesting(start, duration, amount, uint64(block.timestamp)) - released[_tokenId];\n    }\n\n    /// @notice Release the tokens that have already vested.\n    function release(bytes32[] memory _proof, uint256 _tokenId) public virtual {\n        if (!verifyTokenid(_proof, _tokenId)) {\n            revert InvalidProof(_proof, _tokenId);\n        }\n\n        address releaseBeneficiary = beneficiary(_tokenId);\n        uint96 releaseAmount = releasable(_tokenId);\n        released[_tokenId] += releaseAmount;\n        reward(releaseBeneficiary, releaseAmount);\n    }\n\n    function verifyTokenid(bytes32[] memory _proof, uint256 _tokenId) public view returns (bool valid) {\n        bytes32 leaf = keccak256(bytes.concat(keccak256(abi.encode(_tokenId))));\n        return MerkleProof.verify(_proof, merkletreeRoot, leaf);\n    }\n}\n"},"src/vesting/VestingUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary VestingUtils {\n    // From Openzeppelin VestingWallet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.0/contracts/finance/VestingWallet.sol)\n    function linearVesting(uint64 start, uint64 duration, uint96 totalAllocation, uint64 timestamp)\n        internal\n        pure\n        returns (uint96)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp >= (start + duration)) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"evmVersion":"shanghai","viaIR":true},"metadata":{"useLiteralContent":true}},"license":"MIT"},"source":"/home/plopmenz/erc20-vesting","submitted":{"transactionHash":"0x29db8aa5bd7c4b7d970b15d8b2a9b80b45f2d24cdc7892aae24e9c9567623562","date":"2024-06-07T10:11:58.674Z"}}